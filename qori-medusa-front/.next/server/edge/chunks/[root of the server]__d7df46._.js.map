{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/src/middleware.ts"],"sourcesContent":["import { HttpTypes } from \"@medusajs/types\"\r\nimport { NextRequest, NextResponse } from \"next/server\"\r\n\r\nconst BACKEND_URL = process.env.MEDUSA_BACKEND_URL\r\nconst PUBLISHABLE_API_KEY = process.env.NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY\r\nconst DEFAULT_REGION = process.env.NEXT_PUBLIC_DEFAULT_REGION || \"us\"\r\n\r\nconst regionMapCache = {\r\n  regionMap: new Map<string, HttpTypes.StoreRegion>(),\r\n  regionMapUpdated: Date.now(),\r\n}\r\n\r\nasync function getRegionMap(cacheId: string) {\r\n  const { regionMap, regionMapUpdated } = regionMapCache\r\n\r\n  if (!BACKEND_URL) {\r\n    throw new Error(\r\n      \"Middleware.ts: Error fetching regions. Did you set up regions in your Medusa Admin and define a MEDUSA_BACKEND_URL environment variable? Note that the variable is no longer named NEXT_PUBLIC_MEDUSA_BACKEND_URL.\"\r\n    )\r\n  }\r\n\r\n  if (\r\n    !regionMap.keys().next().value ||\r\n    regionMapUpdated < Date.now() - 3600 * 1000\r\n  ) {\r\n    // Fetch regions from Medusa. We can't use the JS client here because middleware is running on Edge and the client needs a Node environment.\r\n    const { regions } = await fetch(`${BACKEND_URL}/store/regions`, {\r\n      headers: {\r\n        \"x-publishable-api-key\": PUBLISHABLE_API_KEY!,\r\n      },\r\n      next: {\r\n        revalidate: 3600,\r\n        tags: [`regions-${cacheId}`],\r\n      },\r\n      cache: \"force-cache\",\r\n    }).then(async (response) => {\r\n      const json = await response.json()\r\n\r\n      if (!response.ok) {\r\n        throw new Error(json.message)\r\n      }\r\n\r\n      return json\r\n    })\r\n\r\n    if (!regions?.length) {\r\n      throw new Error(\r\n        \"No regions found. Please set up regions in your Medusa Admin.\"\r\n      )\r\n    }\r\n\r\n    // Create a map of country codes to regions.\r\n    regions.forEach((region: HttpTypes.StoreRegion) => {\r\n      region.countries?.forEach((c) => {\r\n        regionMapCache.regionMap.set(c.iso_2 ?? \"\", region)\r\n      })\r\n    })\r\n\r\n    regionMapCache.regionMapUpdated = Date.now()\r\n  }\r\n\r\n  return regionMapCache.regionMap\r\n}\r\n\r\n/**\r\n * Fetches regions from Medusa and sets the region cookie.\r\n * @param request\r\n * @param response\r\n */\r\nasync function getCountryCode(\r\n  request: NextRequest,\r\n  regionMap: Map<string, HttpTypes.StoreRegion | number>\r\n) {\r\n  try {\r\n    let countryCode\r\n\r\n    const vercelCountryCode = request.headers\r\n      .get(\"x-vercel-ip-country\")\r\n      ?.toLowerCase()\r\n\r\n    const urlCountryCode = request.nextUrl.pathname.split(\"/\")[1]?.toLowerCase()\r\n\r\n    if (urlCountryCode && regionMap.has(urlCountryCode)) {\r\n      countryCode = urlCountryCode\r\n    } else if (vercelCountryCode && regionMap.has(vercelCountryCode)) {\r\n      countryCode = vercelCountryCode\r\n    } else if (regionMap.has(DEFAULT_REGION)) {\r\n      countryCode = DEFAULT_REGION\r\n    } else if (regionMap.keys().next().value) {\r\n      countryCode = regionMap.keys().next().value\r\n    }\r\n\r\n    return countryCode\r\n  } catch (error) {\r\n    if (process.env.NODE_ENV === \"development\") {\r\n      console.error(\r\n        \"Middleware.ts: Error getting the country code. Did you set up regions in your Medusa Admin and define a MEDUSA_BACKEND_URL environment variable? Note that the variable is no longer named NEXT_PUBLIC_MEDUSA_BACKEND_URL.\"\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Middleware to handle region selection and onboarding status.\r\n */\r\nexport async function middleware(request: NextRequest) {\r\n  let redirectUrl = request.nextUrl.href\r\n\r\n  let response = NextResponse.redirect(redirectUrl, 307)\r\n\r\n  let cacheIdCookie = request.cookies.get(\"_medusa_cache_id\")\r\n\r\n  let cacheId = cacheIdCookie?.value || crypto.randomUUID()\r\n\r\n  const regionMap = await getRegionMap(cacheId)\r\n\r\n  const countryCode = regionMap && (await getCountryCode(request, regionMap))\r\n\r\n  const urlHasCountryCode =\r\n    countryCode && request.nextUrl.pathname.split(\"/\")[1].includes(countryCode)\r\n\r\n  // if one of the country codes is in the url and the cache id is set, return next\r\n  if (urlHasCountryCode && cacheIdCookie) {\r\n    return NextResponse.next()\r\n  }\r\n\r\n  // if one of the country codes is in the url and the cache id is not set, set the cache id and redirect\r\n  if (urlHasCountryCode && !cacheIdCookie) {\r\n    response.cookies.set(\"_medusa_cache_id\", cacheId, {\r\n      maxAge: 60 * 60 * 24,\r\n    })\r\n\r\n    return response\r\n  }\r\n\r\n  // check if the url is a static asset\r\n  if (request.nextUrl.pathname.includes(\".\")) {\r\n    return NextResponse.next()\r\n  }\r\n\r\n  const redirectPath =\r\n    request.nextUrl.pathname === \"/\" ? \"\" : request.nextUrl.pathname\r\n\r\n  const queryString = request.nextUrl.search ? request.nextUrl.search : \"\"\r\n\r\n  // If no country code is set, we redirect to the relevant region.\r\n  if (!urlHasCountryCode && countryCode) {\r\n    redirectUrl = `${request.nextUrl.origin}/${countryCode}${redirectPath}${queryString}`\r\n    response = NextResponse.redirect(`${redirectUrl}`, 307)\r\n  }\r\n\r\n  return response\r\n}\r\n\r\nexport const config = {\r\n  matcher: [\r\n    \"/((?!api|_next/static|_next/image|favicon.ico|images|assets|png|svg|jpg|jpeg|gif|webp).*)\",\r\n  ],\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}